---
title: "Merriman Data Pull"
author: "Alea Wilbur"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
---

```{r setup, include = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)


library(tidyverse)
library(DBI)
library(data.table)
library(ggspatial)
library(gstat)
library(here)
library(httr)
library(jsonlite)
library(ptaxsim)
library(sf)
library(stars)
library(glue)
library(lmtest)
library(huxtable) # for summ() and regression output formatting
# Create the DB connection with the default name expected by PTAXSIM functions
library(jtools)
library(plm) #for fixed effects
#install.packages("modelsummary")
library(modelsummary)


ptaxsim_db_conn <- DBI::dbConnect(RSQLite::SQLite(), "./ptaxsim.db/ptaxsim-2021.0.4.db")


#set_summ_defaults(digits = 2, pvals = FALSE, robust = "HC3" )
```

From agency.R code in ptaxsim Gitlab "The levy of each jurisdiction is reported by the Cook County Clerk's Office. URL here: <https://www.cookcountyclerkil.gov/service/tax-extension-and-rates>



PTELL = Property Tax Extension Law Limit.

Assessed value as equalized (AVE) = (assessed value \* equalization factor)

People can appeal their assessed values (assessed value is 10% of market value for residential)

Taxable Value of property = Equalized Assessed Value (EAV) = "assessed value as equalized"-exemptions

Note:

-   EAV from tax_bill() command is the EAV before exemptions are removed. Think of it like the "starting point" before it is manipulated at all.\
-   That is different than the EAV from the clerk office on PDFs (which is after exemptions.... and tifs?)

Exemptions lower tax bills by reducing the equalized assessed value of your property.

Taxing District tax levy / taxable value in the district = District Tax Rate

Number of taxing districts includes any district which has levied at some point in the past and has not been terminated by its governing jurisdiction plus TIFs

Chicago general composite rate does not include special districts such as mosquito abatement, special service areas, or home equity assurance district


Random notes:

Goal: Estimate the revenue elasticity of the property tax base.

Theory: Revenue elasticity of the tax base might be equal to zero at least in expected value (all else being equal).

-   beta = dtaxlevy/dEAV\
-   Beta = (change in tax levy)/(change in EAV)

(%change/%change=elasticity)

Need:

-   EAV for every taxing body in every year\
-   Tax Base = sum(all EAVs of all properties in its district)
    -   Except for any region of the agency that is in a TIF where the base is frozen\
-   Tax Levy for every taxing body in every year
    -   Levies = tax extensions. Total dollar amount each taxing agency decides to collect from property owners in its district
    
    
Model notes: you must set robust to either "HC1", "HC2", or "HC3" in order to have clustered standard errors

# Data Gathering and Cleaning

## Muni districts
```{r agency-dt}
# has EAV values, extensions by agency_num
agency_dt <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT *
  FROM agency
  "
) %>%
  mutate(first6 = str_sub(agency_num,1,6),
         first5 = str_sub(agency_num,1,5)
         ) %>%
mutate(year = as.character(year))



# grabs all unique muni names. Would be needed if creating a loop for calculating all munis
# municipality names and their agency number


muni_agency_names <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT DISTINCT agency_num, agency_name, minor_type
  FROM agency_info
  WHERE minor_type = 'MUNI'
  OR agency_num = '020060000'
  "
  ) %>% 
  mutate(first6 = str_sub(agency_num,1,6),
         first5 = str_sub(agency_num,1,5)
         ) %>%
  select(-minor_type)


```


```{r triads}
# took from one of Josh files. Made pivot table of his agencies and their triad 
# then saved the info as a csv on my computer named muni_agency_triads
triads <-  read_csv("muni_agency_triads.csv") 


# has binary variable for if it was a reassessment year or not. 
# Manually created based on the 3 year rotation used for reassessments.
reassessment_years <- read_csv("triad_reassessment_years.csv")

reassessments_long <- reassessment_years %>% pivot_longer(cols = c(`2006`:`2021`), names_to = "year", values_to = "reassess_year")
head(reassessments_long)
```


```{r}
# all_taxing_agencies %>% filter(minor_type == "TOWNSHIP")

# North <- c("020010000", "020070000", "020080000", "020090000", "020110000","020130000", "020140000", "020150000", "020160000","020170000", "020200000", "020260000", "020290000" )
# 
# South <- c("020020000", "020030000","020040000","020050000", "020060000", "020100000", "020120000", "020180000", "020190000", "020210000", "020220000", "020230000","020240000", "020250000", "020270000", "020280000", "020300000") 
# 
# # Chicago townships include Hyde Park, Jefferson, Lake, Lakeview, North Chicago, Rogers Park, South Chicago, West Chicago.
# Chicago <- c("030210000")

# 
# muni_agency_names <- muni_agency_names %>% 
#   mutate(agency_num = as.character(agency_num) )%>%
#   mutate(
#     triad = ifelse(agency_num %in% North, "North", "")) %>%
#   mutate(
#     triad = ifelse(agency_num %in% South, "South", triad),
#     triad = ifelse(agency_num %in% Chicago, "Chicago", triad))


muni_agency_names <- muni_agency_names %>% left_join(triads)

table(muni_agency_names$triad)


```

```{r agency_info-dt}
# all agency names, numbers, and types
# includes TIF and non-TIF agencies
all_taxing_agencies <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT agency_num, agency_name, major_type, minor_type
  FROM agency_info
  "
)


all_taxing_agencies <- all_taxing_agencies %>%
  mutate(first6 = str_sub(agency_num,1,6),
        first5 = str_sub(agency_num,1,5)
         )


all_taxing_agencies <- all_taxing_agencies %>%
left_join(muni_agency_names, by = c("first6", "first5")) %>%
 rename(muni_name =  agency_name.y,
        muni_num = agency_num.y,
        agency_name = agency_name.x,
        agency_num = agency_num.x) 

```


```{r}
agency_dt <- left_join(agency_dt, all_taxing_agencies, by = c("agency_num", "first5", "first6"))

agency_dt <- left_join(agency_dt, reassessments_long, by = c("triad" = "Triad", "year"))

agency_dt %>% arrange(triad) %>% head
```


```{r eval=FALSE}

grouped_munis <- agency_dt %>% 
  mutate(cty_cook_eav = as.numeric(cty_cook_eav), # EAV after exemptions
         total_final_levy = as.numeric(total_final_levy), # value that matches Clerk Office PDF for Levy
         cty_cook_eav = ifelse(cty_cook_eav < 1, NA, cty_cook_eav), # Code as missing so Log() doesn't make -Inf
         total_final_levy = ifelse(total_final_levy <1, NA, total_final_levy)) %>%
  group_by(muni_name, year) %>%
  summarize(levy_sum = sum(total_final_levy, na.rm = TRUE), 
            eav = first(cty_cook_eav), 
            log_levy = log(levy_sum),
            log_eav = log(eav),
            year=first(year)
)
grouped_munis
table(grouped_munis$year)

grouped_munis_rectangle <- grouped_munis %>% filter(!is.na(muni_name) & !is.na(year))

grouped_munis_rectangle

table(grouped_munis_rectangle$year)


# All Agencies-Agency & Year FE"
grouped_model<- plm(log_levy ~ log_eav, 
             index = c("muni_name", "year"), 
             model = "within", 
             effect= "twoways",                    
             data = grouped_munis_rectangle)

model_names <- c(grouped_model = "Grouped Munis with Summed Levies")

export_summs(grouped_model, robust = "HC3",  model.names = model_names, statistics = c(N = "nobs", R2 = "r.squared"))
plot(grouped_model)
```


```{r agency_info-dt2}
# add taxing agency names and agency type to data table that has eav and extension values
agency_data <- agency_dt %>% 
  #right_join(agency_dt, all_taxing_agencies, by = c("first6", "first5", "agency_num")  ) %>%
  mutate(first2 = str_sub(agency_num, 1,2),
         last2 = str_sub(agency_num,8,9),
         in_SSA = ifelse(minor_type == "SSA", 1,0),
         in_chicago = ifelse(str_detect(agency_name, "CHICAGO"),1,0)) %>%
  select(-c(cty_dupage_eav:cty_livingston_eav)) 

agency_data <- agency_data %>% 
  mutate(cty_cook_eav = as.numeric(cty_cook_eav), # EAV after exemptions
         total_final_levy = as.numeric(total_final_levy), # value that matches Clerk Office PDF for Levy
         cty_cook_eav = ifelse(cty_cook_eav < 1, NA, cty_cook_eav), # Code as missing so Log() doesn't make -Inf
         total_final_levy = ifelse(total_final_levy <1, NA, total_final_levy)) %>%
  mutate(log_eav = log(cty_cook_eav), 
         log_levy = log(total_final_levy))
    
```



```{r eval=FALSE, include=FALSE}
# loop practice
# calculates  the mean for every variable at once

output <- vector("double", ncol(agency_data))
names(output) <- names(agency_data)
for (i in names(agency_data)) {
  output[i] <- mean(agency_data[[i]], na.rm=TRUE)
}
output

# calculates the number of observations for each variable
output <- vector("double", ncol(agency_data))
names(output) <- names(agency_data)
for (i in names(agency_data)) {
  output[i] <- n_distinct(agency_data[[i]])
}
output

```






- Cook County is divided into three triads for assessment purposes: (1) Chicago, (2) North (suburban Cook north of North Avenue), and (3) South (suburban Cook south of North Avenue).  One triad is reassessed each year on a rotating basis while the other two are held constant, except for new construction.  For 2020 taxes (payable in 2021) the South triad was reassessed. 

## School Districts and Taxcodes

```{r agency-dt}
# has EAV values, extensions by agency_num
agency_dt <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT *
  FROM agency
  WHERE year = 2021
  "
)

school_agency_names <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT DISTINCT agency_num, agency_name, minor_type
  FROM agency_info
  WHERE major_type = 'SCHOOL'
  "
  )

# grabs all unique muni names. Would be needed if creating a loop for calculating all munis
# municipality names and their agency number

school_agency_nums<- all_taxing_agencies %>% 
  filter(major_type %in% c("SCHOOL"))  %>%
   select(agency_num)


school_tax_codes <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  glue_sql("
  SELECT*
  FROM tax_code
  WHERE agency_num IN  ({school_agency_names$agency_num*})
  AND year = 2021
  ",
  .con = ptaxsim_db_conn
  )
)

# grab taxcodes that are also taxed by municipalities to help identify where these schools are located

muni_agency_names <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  "SELECT DISTINCT agency_num, agency_name, minor_type
  FROM agency_info
  WHERE minor_type = 'MUNI'
  OR agency_num = '020060000'  

  "
)

muni_agency_names <- muni_agency_names %>%
  select(-minor_type)



#Makes a list of ALL taxing agencies, including TIFs, SSAs, etc.



muni_tax_codes <- DBI::dbGetQuery(
  ptaxsim_db_conn,
  glue_sql("
  SELECT*
  FROM tax_code
  WHERE agency_num IN ({muni_agency_names$agency_num*})
  AND year = 2021
  ",
  .con = ptaxsim_db_conn
  )
) %>% left_join(muni_agency_names)

school_tax_codes <- school_tax_codes %>% 
  left_join(all_taxing_agencies) %>%
  left_join(school_agency_names)#,

school_tax_codes <- school_tax_codes %>% left_join(muni_tax_codes, by = "tax_code_num")
#left_join(muni_agency_names, by = c("first6", "first5")
# school_agency_names
school_tax_codes
```


# Samples and Models

Simple model was log(levy) \~ log(base) where each observation is an agency-year and the base is the sum of that jurisdiction's taxable eav. (The taxable eav = equalized assessed value - TIF increments - exemptions)

The coefficients would be interpreted as "a x% change in eav leads to a y% change in levy", which is also the elasticity.


- plm() uses the entity-demeaned OLS algorithm and does not report dummy coefficients.

- robust has multiple options: HC0 to HC5. Default is set to "HC3 BUT Stata default is to use "HC1"

[Command and package author site for summ() and table formatting](https://jtools.jacob-long.com/reference/summ.lm.html) 

model = "within" is the same as creating dummies for all agencies


## All Agencies

```{r}
# tax base = log(levy)
# estimate the fixed effects regression with plm()


panel_data <- agency_data %>% 
  filter(minor_type!="TIF") %>%
      mutate(eav_lag1 = lag(log_eav, n = 1),
         eav_lag2 = lag(log_eav, n = 2),
         reassess_lag1 = lag(reassess_year, n=1),
         reassess_lag2 = lag(reassess_year, n=2)
                             ) %>%
  select(year, agency_name, agency_num, major_type, minor_type, 
         cty_cook_eav, total_final_levy, log_eav, log_levy, total_final_rate, 
         in_chicago, in_SSA, triad, eav_lag1, eav_lag2, reassess_year:reassess_lag2
  ) 

#write_csv(panel_data, "panel_data_June29AWM.csv")
panel_data<-pdata.frame(panel_data, index = c("agency_name", "year")) %>%
    mutate(eav_lag1 = lag(log_eav, n = 1),
         eav_lag2 = lag(log_eav, n = 2),
         reassess_lag1 = lag(reassess_year, n=1),
         reassess_lag2 = lag(reassess_year, n=2)
                             ) 
  


all_agencies <- panel_data 

# All Agencies-Agency & Year FE"
all_m1_simple<- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = all_agencies)

all_m1<- plm(log_levy ~ log_eav + reassess_year + reassess_lag1 + reassess_lag2 + triad + eav_lag1 + eav_lag2, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = all_agencies)

model_names <- c( all_m1_simple = "All Agencies FE, log(levy~log(eav)", all_m1 = "All Agencies-Agency & Year FE, lags")

export_summs(all_m1_simple, all_m1, robust = "HC3",  model.names = model_names, statistics = c(N = "nobs", R2 = "r.squared", adjR2 = "adj.r.squared"))
```

Before the added variables, there were 13,516 observations for All agencies. Now there are 5,735.


### Munis Only 

If you only want the 134 municipalities within Cook County, then use minor_type == MUNI. We probably want this. 

Major_type == Muni includes things paid for by the municipality but separately such as library, health, muni, township, and general assistance taxing agencies.

```{r}


minortype_munis <- agency_data %>% 
  filter(minor_type == "MUNI") %>%
  select(year, agency_name, agency_num, major_type, minor_type, 
         cty_cook_eav, total_final_levy, log_eav, log_levy, total_final_rate, home_rule_ind, 
         in_chicago, in_SSA, triad, reassess_year)  

minortype_munis <- pdata.frame(minortype_munis, index = c("agency_name", "year")) %>%
 # filter(agency_num %in% muni_agency_names$agency_num  ) %>%
  mutate(eav_lag1 = lag(log_eav, n = 1),
         eav_lag2 = lag(log_eav, n = 2),
         reassess_lag1 = lag(reassess_year, n=1),
         reassess_lag2 = lag(reassess_year, n=2)
                             )


minortype_munis %>% ggplot()+
  geom_point(aes(x=log(cty_cook_eav), y=log(total_final_levy), col=agency_name, alpha = .1)) +
  theme(legend.position = "none")+
  ggtitle("Minor Type: Logged EAV vs Logged Levy \n Homerule & non-Homerule Together")


minortype_munis %>% 
  ggplot(aes(x=year, 
             y= log(total_final_levy)/log(cty_cook_eav), 
             group = agency_name
               )  )+
  geom_line(alpha = .1)+
  ggtitle("134 Municipalities based on Minor Type: \nLogged EAVLogg/ed Levy Over Time \n Homerule & non-Homerule Together")
```



#### Minor_type Munis: Homerule

```{r}


# homerule_minortype_munis <- minortype_munis %>% 
#   filter(minor_type == "MUNI") %>%
#   
#   select(year, agency_name, agency_num, major_type, minor_type, 
#          cty_cook_eav, total_final_levy, log_eav, log_levy, total_final_rate, 
#          in_chicago, in_SSA, triad, reassess_year) %>%
#   filter(agency_num %in% muni_agency_names$agency_num  
#  ) %>%
#   mutate(eav_lag1 = lag(log_eav, n = 1),
#          eav_lag2 = lag(log_eav, n = 2),
#          reassess_lag1 = lag(reassess_year, n=1),
#          reassess_lag2 = lag(reassess_year, n=2)
#                              )

homerule_minortype_munis <- minortype_munis %>% 
  filter(agency_num %in% muni_agency_names$agency_num & 
           home_rule_ind==1 # Homerule only
 ) %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy, eav_lag1,eav_lag2 , triad, reassess_year:reassess_lag2
         ) 

hr_muni_minor_simple <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = homerule_minortype_munis)

plot(hr_muni_minor_simple)


hr_muni_minor <- plm(log_levy ~ log_eav + reassess_year + reassess_lag1 + reassess_lag2 + triad + eav_lag1 + eav_lag2, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = homerule_minortype_munis)


# homerule_minortype_munis %>% 
#   ggplot()+
#   geom_point(aes(x=log(cty_cook_eav), y=log(total_final_levy), col=agency_name), alpha=.5) +
#   theme(legend.position="none")+
#   ggtitle("Homerule Muni: Logged EAV vs Logged Levy")
# 
# 

homerule_minortype_munis %>% 
  ggplot(aes(x=year, 
             y= log(total_final_levy)/log(cty_cook_eav), 
             group = agency_name, color= minor_type
               )  )+
  geom_line(alpha = .3)+
  ggtitle("Homerule Muni: Logged EAV/Logged Levy over Time")
```



#### Minor_type Munis: Homerule - No Chicago

```{r}


# homerule_minortype_munis <- minortype_munis %>% 
#   filter(minor_type == "MUNI") %>%
#   
#   select(year, agency_name, agency_num, major_type, minor_type, 
#          cty_cook_eav, total_final_levy, log_eav, log_levy, total_final_rate, 
#          in_chicago, in_SSA, triad, reassess_year) %>%
#   filter(agency_num %in% muni_agency_names$agency_num  
#  ) %>%
#   mutate(eav_lag1 = lag(log_eav, n = 1),
#          eav_lag2 = lag(log_eav, n = 2),
#          reassess_lag1 = lag(reassess_year, n=1),
#          reassess_lag2 = lag(reassess_year, n=2)
#                              )

homerule_minortype_munis_nochi <- minortype_munis %>% 
  filter(agency_num %in% muni_agency_names$agency_num & 
           home_rule_ind==1, # Homerule only
         triad != "City") %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy, eav_lag1,eav_lag2 , triad, reassess_year:reassess_lag2
         ) 

nochi_hr_muni_minor_simple <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = homerule_minortype_munis_nochi)

plot(hr_muni_minor_simple)


nochi_hr_muni_minor <- plm(log_levy ~ log_eav + reassess_year + reassess_lag1 + reassess_lag2 + triad + eav_lag1 + eav_lag2, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = homerule_minortype_munis_nochi)


# homerule_minortype_munis %>% 
#   ggplot()+
#   geom_point(aes(x=log(cty_cook_eav), y=log(total_final_levy), col=agency_name), alpha=.5) +
#   theme(legend.position="none")+
#   ggtitle("Homerule Muni: Logged EAV vs Logged Levy")
# 
# 

homerule_minortype_munis_nochi %>% 
  ggplot(aes(x=year, 
             y= log(total_final_levy)/log(cty_cook_eav), 
             group = agency_name, color= minor_type
               )  )+
  geom_line(alpha = .3)+
  ggtitle("Homerule Muni: Logged EAV/Logged Levy over Time")
```



#### Minor_type Muni - Non-homerule

```{r filtering-agencies2}
non_homerule_munis <- minortype_munis %>% 
  filter(agency_num %in% muni_agency_names$agency_num & 
           home_rule_ind==0 )


nonhr_muni_minor_simple <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways", 
             data = non_homerule_munis)

nonhr_muni_minor <- plm(log_levy ~ log_eav + reassess_year + reassess_lag1 + reassess_lag2 + triad + eav_lag1 + eav_lag2, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways", 
             data = non_homerule_munis)

summary(nonhr_muni_minor_simple)
summary(nonhr_muni_minor)

non_homerule_munis %>% 
  ggplot(aes(x=year, 
             y= log(total_final_levy)/log(cty_cook_eav), 
             group = agency_name, color= minor_type
               )  )+
  geom_line(alpha = .5)+theme(legend.position = "none")+
  ggtitle("Non Homerule Municipalities: Logged EAV/Logged Levy over Time")

model_names <- c("All Agencies", "Simple Homerule General Muni", "Homerule General Muni", "Simple Non-homerule Munis", "Non-homerule Munis", "Simple Homerule Muni - No Chicago", "Homerule General Muni - No Chicago"
                 )
# coefs <- c("","") # to make names nicer

export_summs(all_m1, hr_muni_minor_simple, hr_muni_minor, nonhr_muni_minor_simple, nonhr_muni_minor, nochi_hr_muni_minor_simple, nochi_hr_muni_minor, model.names = model_names, statistics = c(N = "nobs", R2 = "r.squared"))
```



major_type == "MUNICIPALITY/TOWNSHIP" includes items provided by the municipality but a different taxing agency associated with the "Village of.. " or "City of..". 

> Need to decide if this matters: Stick with the true minor_type=MUNI or combine major_type=MUNICIPALITY taxing agencies using the first 5 or 6 digits of the taxing agency? Probably the first option but just checking.

#### Major_type Municipalities - Homerule

```{r}
homerule_majortype_munis <- agency_data %>% 
  filter(major_type == "MUNICIPALITY/TOWNSHIP" & 
           home_rule_ind==1 # Homerule only
 ) %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy
         ) 

hr_muni1 <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = homerule_majortype_munis)
```

#### Major_type Municipalities - Non-Homerule

```{r}
nonhr_muni_major <- agency_data %>% 
  filter(major_type == "MUNICIPALITY/TOWNSHIP" & 
           home_rule_ind==0 # Homerule only
 ) %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy
         ) 

nonhr_muni_maj <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = nonhr_muni_major)

```


### Muni Model Results

majortype: Uses all taxing agencies that have a major_type == "MUNI/TOWNSHIP". Includes many more taxing agencies than just the 134 muni taxing agencies.  Split into homerule and nonhomerule. 

Municipality models (minorType) use the 134 municipality taxing agencies from 2006-2021. Split into home rule and non homerule.


```{r}
model_names <- c("All Agencies", "Homerule Muni (MinorType)", "Non-homerule Munis (MinorType)", "Homerule Muni (MajorType)", "Non-homerule Muni (Major Type)"
                 )
# coefs <- c("","") # to make names nicer

export_summs(all_m1, hr_muni_minor, nonhr_muni_minor, hr_muni1, nonhr_muni_maj, model.names = model_names, statistics = c(N = "nobs", R2 = "r.squared"))
#export_summs(m1, m2, m3, model.names = model_names, scale=TRUE, robust = "HC1")
```

 
#### All major type munis

Does not separate home rule and non-homerule taxing agencies in the majortype_munis model. 

majortype_munis_filtered excludes townships and SSAs so far. 

```{r}
# All Major Munis
majortype_munis <- agency_data %>% 
  filter(major_type == "MUNICIPALITY/TOWNSHIP" ) %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy
         ) 

majortype_munis <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = majortype_munis)


# All Major Munis: removing SSAs and TOWNSHIPS 
majortype_munis_filtered <- agency_data %>% 
  filter(major_type == "MUNICIPALITY/TOWNSHIP" & 
         !(minor_type %in% c("TOWNSHIP", "SSA"))
 ) %>% 
  select(year, agency_name, agency_num, 
         major_type, minor_type, cty_cook_eav, 
         total_final_levy,  total_final_rate,
         log_eav, log_levy
         ) 
majortype_munis_filtered <- plm(log_levy ~ log_eav, 
             index = c("agency_name", "year"), 
             model = "within", effect= "twoways",                    
             data = majortype_munis_filtered)
```


The major type municipal Muni models above still include SSAs and 

```{r}
# Models for Major Muni types. Includes homerule and nonhomerule together!! 
# one model removes SSAs and Townships (which is the better model. Included other for comparison.)
model_names <- c("All Taxing Agencies" ,"All Munis (MajorType)", "All Munis (MajorType) - Filtered"
                 )
# coefs <- c("","") # to make names nicer

export_summs(all_m1, majortype_munis, majortype_munis_filtered, model.names = model_names, statistics = c(N = "nobs", R2 = "r.squared"))
```



## Expanded Muni Categories

Uses the 5 or 6 digit agency code to combine additional taxing agencies within a municipality together (like libraries, taxing agencies, etc. that are included within the major_type category.)

```{r}
agency_dt %>% 
  filter(major_type == "MUNICIPALITY/TOWNSHIP" & year == 2021) %>% 
  group_by(muni_name) %>% select(muni_name, agency_name, cty_cook_eav, total_final_levy)

# agency_dt %>% 
#   filter(major_type == "MUNICIPALITY/TOWNSHIP") %>% 
#   group_by(muni_name) %>%
#   summarize(EAV = max(cty_cook_eav),
#             Levy = sum(total_final_levy))
```

Manually coding grouping Muni's that have shared EAV and share a municipality. 

Example: Stickney is a town and a village. The Road and Bridge Stickney taxing agency is for the Township (I think) - it has an eav of 1,226,209,940
```{r}
#handcoded_munis<-readxl::read_excel("grouped_munis_manual_entry.xlsx")
```
 

## Schools

```{r}
schools <- agency_data %>% 
  filter(major_type=="SCHOOL")  %>% 
  select(agency_name, year, agency_num, log_levy, log_eav, minor_type)
# group schools by minor type later!

# model wouldn't work until I selected only a few variables. in line above


table(schools$minor_type)



schools %>% 
  ggplot(aes(x =year, 
             y = log_levy/log_eav, 
             col = minor_type, label = agency_name))+
  geom_point(alpha=.5)# +theme(legend.position = "none")

```

### School Models


```{r}

# based on major_type == Schools. Groups all schools together. 
school_mod_major <- plm(log_levy ~ log_eav, index = c("agency_name", "year"), 
                  model = "within",  effect= "twoways", data = schools)

school_mod_secondary <- plm(log_levy ~ log_eav, 
                        subset = minor_type == "SECONDARY", 
                        index = c("agency_name", "year"), model = "within",  
                        effect= "twoways", data = schools)

school_mod_unified <- plm(log_levy ~ log_eav, 
                        subset = minor_type == "UNIFIED", 
                        index = c("agency_name", "year"), model = "within",  
                        effect= "twoways", data = schools)

school_mod_elementary <- plm(log_levy ~ log_eav, subset = minor_type == "ELEMENTARY", 
                             index = c("agency_name", "year"), model = "within",  
                             effect= "twoways", data = schools)

school_mod_comcol <- plm(log_levy ~ log_eav, index = c("agency_name", "year"), 
                         subset = minor_type == "COMM COLL", model = "within",  
                         effect= "twoways", data = schools)




model_names = c("All Schools", "Secondary", "Elementary", "Com. Colleges", "Unified" )
export_summs(school_mod_major, school_mod_secondary, school_mod_elementary, school_mod_comcol, school_mod_unified, model.names = model_names, robust=TRUE, statistics = c(N = "nobs", adjR2 = "adj.r.squared"))

plot(school_mod_elementary)
```



```{r}

schools <- schools %>%
  arrange(year) %>%
  group_by(agency_num) %>%
  mutate(eav_lag1 = lag(log_eav, n = 1, order_by = year, default = NA)) %>%
  ungroup()

schools <- schools %>%
  arrange(year) %>%
  group_by(agency_num) %>%
  mutate(eav_lag2 = lag(log_eav, n = 2, order_by = year, default = NA)) %>%
  ungroup()

schools <- schools %>%
  arrange(year) %>%
  group_by(agency_num) %>%
  mutate(eav_lag3 = lag(log_eav, n = 3, order_by = year, default = NA)) %>%
  ungroup()
```



## More graphs

Levy variables exploration:

-   Total Levy is what they asked for\
-   Total extension is what was actually collected?

Taxing District Tax Levy / Taxable Value in a Taxing District = District Tax Rate

Therefore, **Levy/TaxRate = TaxableValue**

TaxableValue = original EAV - exemptions - TIF increment






EAV exploration:

-   Summed EAV for each Agency - Michael's default way of thinking

-   cty_total_eav = all county EAVs summed together (LaSalle, Will, Cook, etc.)\

-   cty_cook_eav = eav after exemptions in cook county for a taxing district

Why are the other counties included in there? - Some taxing districts extend outside of cook county. cty_lasalle_eav would have eav that is in LaSalle County.

```{r}
agency_data %>% ggplot()+
  geom_point(aes(x=as.numeric(cty_total_eav), y=as.numeric(cty_cook_eav), col=major_type))+
  ggtitle("Total County EAV and Cook County EAV")
```

```{r}
agency_data %>% ggplot()+
  geom_point(aes(x=log(cty_cook_eav), y=log(total_final_levy), col=major_type, alpha=.1)) +
  ggtitle("Logged EAV vs Logged Levy for ALL agencies and all years")
```

### Graphs for Munis only




```{r}
agency_data %>% 
  filter(year == 2021) %>% #2021 only
  
  # not in Chicago and municipalitys + Cicero
  filter(!(agency_num %in% c("030210000", "030210001", "030210002" ) ) 
         & (minor_type == "MUNI" | agency_num =="020060000")) %>%
  ggplot(aes(x=cty_cook_eav, y=total_final_levy, col=minor_type, label = agency_name))+
  geom_point(aes(alpha=0.4)) + 
  labs(title = "2021 only: Municipality EAV & Levy")

agency_data %>% 
  filter(!(agency_num %in% c("030210000", "030210001", "030210002" ) ) 
         & (minor_type == "MUNI" | agency_num =="020060000")) %>%
  ggplot(aes(x=cty_cook_eav, y=total_final_levy, color=agency_name, group = agency_name))+
  geom_point(alpha=.54) +
theme(legend.position = "none")+
    labs(title = "All Years: Municipality EAV & Levy")


agency_data %>% 
  filter(!(agency_num %in% c("030210000", "030210001", "030210002" ) ) 
         & (minor_type == "MUNI" | agency_num =="020060000")) %>%
  ggplot(aes(x=log(cty_cook_eav), y=log(total_final_levy), color=agency_name, group = agency_name))+
  geom_point(alpha=.5) +
theme(legend.position = "none")+
    labs(title = "Logged Values All Years: Municipality EAV & Levy")


agency_data %>% 
  filter(year == 2021) %>%
  filter(!(agency_num %in% c("030210000", "030210001", "030210002" ) ) 
         & (minor_type == "MUNI" | agency_num =="020060000")) %>%
  ggplot(aes(x=cty_cook_eav, y=total_final_levy, col=minor_type, label = agency_name))+
  geom_point()+ 
  geom_text(size = 2, vjust=-1.5)
```


```{r munipanels}
muni_panel <- agency_data %>% 
  filter(!(agency_num %in% c("030210000", "030210001", "030210002" ) ) 
         & (minor_type == "MUNI" | agency_num =="020060000")) %>% 
  select(year, agency_name, agency_num, major_type, minor_type, cty_cook_eav, total_final_levy, log_eav, log_levy, total_final_rate
         ) 


plm(log_levy ~ log_eav, 
                   index = c("agency_name", "year"), 
                   model = "within", effect= "twoways",                    
    data = muni_panel) %>% 
  summary()
```







Total Final Levy and Cook County EAV values:

```{r}
agency_data %>% ggplot()+
  geom_point(aes(x=total_final_levy, y=cty_cook_eav, col=major_type))+
  coord_flip()+
  ggtitle("Total Final Levy and Cook County EAV")

agency_data %>% 
  filter(year == 2021) %>%
  filter(minor_type == "MUNI" &
           in_chicago == "0") %>% # Chicago was massive outlier in the uppper right corner
  ggplot(aes(x=total_final_levy, y=cty_cook_eav, col=major_type, label = agency_name))+
  geom_point() +#
coord_flip()+
  ggtitle("Municipalities EAV & Levy")



agency_data %>% ggplot()+
  geom_point(aes(y=total_final_levy, x=cty_cook_eav, col=minor_type))


```

```{r}
agency_data %>% 
  filter(year== 2021) %>% 
  ggplot()+
  geom_point(aes(y=total_final_levy, x=cty_cook_eav, col=major_type))+
  ggtitle("Major Types: Agency EAV vs Final Levy for 2021")

agency_data %>% 
  filter(year== 2021) %>% 
  ggplot()+
  geom_point(aes(y=log(total_final_levy), x=log(cty_cook_eav), col=minor_type))+ 
  ggtitle("Minor Types: Agency EAV vs Final Levy for 2021")
```

### Heteroskedasticity

https://www.econometrics-with-r.org/10-5-tferaaseffer.html


"Similar as for heteroskedasticity, autocorrelation invalidates the usual standard error formulas as well as heteroskedasticity-robust standard errors since these are derived under the assumption that there is no autocorrelation. When there is both heteroskedasticity and autocorrelation so-called heteroskedasticity and autocorrelation-consistent (HAC) standard errors need to be used. Clustered standard errors belong to these type of standard errors. They allow for heteroskedasticity and autocorrelated errors within an entity but not correlation across entities.

As shown in the examples throughout this chapter, it is fairly easy to specify usage of clustered standard errors in regression summaries produced by function like coeftest() in conjunction with vcovHC() from the package sandwich. Conveniently, vcovHC() recognizes panel model objects (objects of class plm) and computes clustered standard errors by default."

The null hypothesis for the Breusch-Pagan test is homoskedasticity.


```{r}
#bptest(log_levy~log_eav + factor(agency_num) + factor(year), data = balanced_panel)
```

Controlling for heteroskedasticity: Robust covariance matrix estimation (Sandwich estimator)

The `vcovHC` function estimates three heteroskedasticity-consistent covariance
estimators:  
• "white1" - for general heteroskedasticity but no serial correlation. Recommended for
random effects.   
• "white2" - is "white1" restricted to a common variance within groups. Recommended
for random effects.   
• "arellano" - both heteroskedasticity and serial correlation. Recommended for fixed
effects.   

```{r}
#coeftest(m1)
#coeftest(m1, vcovHC(fixed, method = "arellano"))
```


