---
title: 'Get and Prepare Data'
---

```{r setup, warning=FALSE, message=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, 
                      message = FALSE)

library(tidyverse)
```

## Access and Summarize Data from PTAXSIM

Bills were originally pulled from PTAXSIM and summed to the PIN level in files `1_...rmd` and `2...rmd`. Exemption data per PIN was pulled from PTAXSIM in file `3_.....rmd`. These were then joined together in `4c_.....` to create the `4c_joined_pins...` CSV.

These files ended up being the building blocks for creating the `ptax_pull_loop.R` file that pulls the data for all the years and aggregates it in various ways.

When looking at tax bill or assessed value distributions at the PIN or parcel level, the joined PIN data containing the taxbills and exemption information for the relevant year must be used. Download `4C_joined_PINs` file from [Box link here:](https://uofi.box.com/s/cvp7pdjkx8kth7o0vg9itpra3z8vfkzq). I would then move it from the download file into your R project and then the file paths should work with few to zero edits.

```{r helper-file}
#| code-fold: false
#| 
setwd("..")   # set directory above current one (set to parent directory)
source("./scripts/helper_tc_muninames.R")
```

General steps for data prep:

1.  Pull tax bill data for all PINs. Summarize the tax bills to the PIN level.\
2.  Pull all exemption data from the `pin` data table in PTAXSIM database.\
3.  Join PIN level observations.\

-   Need data at PIN level for individual level bill change calculations.

4.  Create or join other variables.

```{r, eval=FALSE, include = TRUE}
setwd("..") 
source("ptax_pull_loop.R")
```

Note: `exe_abate` is NOT included in the `all_exemptions` variable.

MVH NOTE: I think we need to add some color to this caveat.\^\^

MVH NOTE: Does the below mean we can stop loading ptaxsim and DBI for most documents? vv

```{r}
#ptaxsim_db_conn <- DBI::dbConnect(RSQLite::SQLite(), "../ptaxsim.db/ptaxsim-2021.0.4.db")

muni_summary <- read_csv("../Output/ptaxsim_muni_level_2006-2021.csv")

muni_MC_summary <- read_csv("../Output/ptaxsim_muni_MC_2006-2021.csv")

MC_TC <- read_csv("../Output/ptaxsim_TC_MC_summaries_2006-2021.csv") %>% filter(year == 2021)
```

`final_tax_to_dist` has the amount that each PIN pays to taxing agencies for services. When summed up to the municipality, township, neighborhood, etc. level, then it becomes the aggregate levy for the taxing agencies taxing the parcels within the geography specified. MVH NOTE: I think we might possibly be able to plausibly make this more parsimonious. Also, do we need to show the heads of those dataframes?

```{r}
#| code-fold: false

head(muni_summary)
head(muni_MC_summary)
head(MC_TC)

muni_summary %>% filter(year == 2021) %>%
  summarise(zeros = sum(zero_bills))


muni_MC_summary %>% filter(year == 2021 & major_class_code == 2) %>%
  summarise(zeros = sum(zero_bills))
  
```

## Tax Rate and Tax Base Change

```{r}
#| label: create-muni_ratechange-csv
#| eval: false

muni_ratechange <- ptax_pins |>
  mutate(class = as.numeric(class)) |>         # Allows for joining later
 # select(-c(propclass_1dig:av.y)) |>
  filter(!clean_name  %in% c("Frankfort", "Homer Glen",  "Oak Brook", "East Dundee", "University Park",  "Bensenville", "Hinsdale", "Roselle", "Deer Park", "Deerfield")) |> 
  # filter(!agency_num %in% cross_county_lines) |>
  group_by(clean_name) |>
  summarize(
    classgroup_PC = n(),
    # projects = n_distinct(both_ids), # mostly for industrial and commercial properties
    pins_withincents = sum(ifelse(class >= 600 & class < 900, 1,0)),
    fmv_incentive = sum(ifelse(class >=600 & class <900, fmv, 0), na.rm = TRUE),
    #fmv_taxed =  sum(taxed_fmv, na.rm=TRUE),
    fmv_incents_inTIFs = sum(ifelse(class >=600 & class <900 & final_tax_to_tif > 0, fmv, 0), na.rm = TRUE),
    fmv_inTIF = sum(ifelse(final_tax_to_tif > 0, fmv, 0), na.rm=TRUE),
    fmv_tif_increment = sum(fmv_tif_increment, na.rm=TRUE),
    fmv_untaxable_value = sum(untaxable_value_fmv , na.rm=TRUE),
    fmv_exemptions = sum(all_exemptions/eq_factor/loa, na.rm=TRUE),
    fmv_abatements = sum(exe_abate/eq_factor/loa, na.rm=TRUE),
    zero_bill = sum(zero_bill, na.rm=TRUE),
    fmv_residential = sum(ifelse(class %in% c(200:399), fmv, 0), na.rm = TRUE),
    fmv_C2 = sum(ifelse(class %in% c(200:299), fmv, 0), na.rm = TRUE),
    
    fmv_industrial = sum(ifelse(class %in% industrial_classes, fmv, 0), na.rm = TRUE),
    fmv_commercial = sum(ifelse(class %in% commercial_classes, fmv, 0), na.rm = TRUE),
    
    current_rate_avg = mean(tax_code_rate),
    avg_C2_bill_noexe = mean(ifelse(between(class,200,299) & all_exemptions == 0, (final_tax_to_dist + final_tax_to_tif), NA), na.rm=TRUE),
    avg_C2_bill_withexe = mean(ifelse(between(class,200,299) & all_exemptions > 0, (final_tax_to_dist + final_tax_to_tif), NA), na.rm=TRUE),
    av_taxed = sum(taxed_av, na.rm = TRUE),
    untaxable_value_av = sum(untaxable_value_av, na.rm=TRUE),
    av = sum(av),
    eav_taxed = sum(taxed_av*eq_factor), 
    eav_untaxable = sum(untaxable_value_eav, na.rm=TRUE),
    eav_tif_increment = sum(final_tax_to_tif/tax_code_rate, na.rm=TRUE),
    eav_max = sum(fmv*loa*eq_factor, na.rm=TRUE),
    fmv = sum(fmv, na.rm=TRUE),
    pins_in_class = n(),
    all_exemptions = sum(all_exemptions),   # in EAV
    abatements = sum(exe_abate),            # in EAV
    eav_incents_inTIFs = sum(ifelse(class >=600 & class <=900 & in_tif == 1, eav, 0), na.rm = TRUE),
    final_tax_to_dist = sum(final_tax_to_dist),
    final_tax_to_tif = sum(final_tax_to_tif),
    eav = sum(eav),
    new_TEAV_noIncents = sum(ifelse(class >=600 & class <900,
                                    (taxed_av*eq_factor/loa)*0.25, taxed_av*eq_factor), na.rm=TRUE),
    
    ####### Not used currently
    # new_TEAV_noC6 = sum(ifelse( class >=600 & class <700, 
    #                             (taxed_av*eq_factor/loa)*0.25 , taxed_av*eq_factor)),
    # new_TEAV_noC7 = sum(ifelse(class >=700 & class <800,
    #                            (taxed_av*eq_factor/loa)*0.25, taxed_av*eq_factor)),
    # new_TEAV_noC8 = sum(ifelse(class >=800 & class <900, (taxed_av*eq_factor/loa)*0.25, taxed_av*eq_factor)),
    # 
    #######

     new_TEAV_vacant_noIncents = sum(ifelse(class >=600 & class <900,
                                            0, taxed_av*eq_factor))
    ) |>
  mutate(
    
    new_TEAV_noExemps = eav_taxed + all_exemptions, # does not include abatements
    new_TEAV_noAbates = eav_taxed + abatements, # include only abatements, not other exemption types
    
    # amount of EAV from taxing an additional 15% of the AV if incentive properties didn't exist
    forgone_EAV_incent = #class_group %in% incentive_majorclasses,
      #incent_prop == "Incentive", 
      new_TEAV_noIncents - eav_taxed) |>
  #cbind(table_cook) |>
  mutate(
    # Absolute maximum TEAV: No Exemptions, no abatements, no TIFS, no Incentive properties
    # Commercial and industrial assessed at 25%
    TEAV_max = eav_taxed + all_exemptions + abatements + eav_tif_increment + forgone_EAV_incent,
    
    # no exemptions or incentive classifications:
    TEAV_neither = eav_taxed + all_exemptions + forgone_EAV_incent,
    
    rate_noExe = final_tax_to_dist / new_TEAV_noExemps * 100,
    rate_noAbate = final_tax_to_dist / new_TEAV_noAbates * 100,
    rate_noInc = final_tax_to_dist / new_TEAV_noIncents * 100,
    rate_neither = final_tax_to_dist / TEAV_neither * 100, 
    rate_noTIFs = final_tax_to_dist / (eav_taxed + eav_tif_increment) * 100,
    rate_vacant = final_tax_to_dist / new_TEAV_vacant_noIncents* 100,
    rate_lowest = final_tax_to_dist / TEAV_max * 100,
    # rate_noC6 = levy / new_TEAV_noC6 * 100,
    # rate_noC7 = levy / TEAV_noC7 * 100,
    # rate_noC8 = levy / TEAV_noC8 * 100,
    rate_current = final_tax_to_dist / eav_taxed * 100,
    change_noInc = rate_current - rate_noInc,
    change_neither = rate_current - rate_neither,
    change_noTIF = rate_current - rate_noTIFs,
    change_noExe = rate_current - rate_noExe,
    change_vacant = rate_current - rate_vacant,
    change_lowest = rate_current - rate_lowest
  )  |>
     mutate(across(contains("rate_"), round, digits = 2)) |>
     mutate(across(contains("change_"), round, digits = 2))

write_csv(muni_ratechange, "../Output/muni_ratechange_2023.csv")
```

```{r}

```

